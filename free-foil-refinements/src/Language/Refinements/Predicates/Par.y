-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.Refinements.Predicates.Par
  ( happyError
  , myLexer
  , pPred
  , pConstBool
  , pOp
  , pListPred
  , pType3
  , pType2
  , pType1
  , pDataTypeArg
  , pListDataTypeArg
  , pType
  , pMeasure
  , pListMeasure
  , pQualifier
  , pListQualifier
  , pQualifierArg
  , pListQualifierArg
  ) where

import Prelude

import qualified Language.Refinements.Predicates.Abs
import Language.Refinements.Predicates.Lex

}

%name pPred Pred
%name pConstBool ConstBool
%name pOp Op
%name pListPred ListPred
%name pType3 Type3
%name pType2 Type2
%name pType1 Type1
%name pDataTypeArg DataTypeArg
%name pListDataTypeArg ListDataTypeArg
%name pType Type
%name pMeasure Measure
%name pListMeasure ListMeasure
%name pQualifier Qualifier
%name pListQualifier ListQualifier
%name pQualifierArg QualifierArg
%name pListQualifierArg ListQualifierArg
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '&&'        { PT _ (TS _ 1)  }
  '\''        { PT _ (TS _ 2)  }
  '('         { PT _ (TS _ 3)  }
  ')'         { PT _ (TS _ 4)  }
  '*'         { PT _ (TS _ 5)  }
  '+'         { PT _ (TS _ 6)  }
  ','         { PT _ (TS _ 7)  }
  '-'         { PT _ (TS _ 8)  }
  '->'        { PT _ (TS _ 9)  }
  ':'         { PT _ (TS _ 10) }
  '<'         { PT _ (TS _ 11) }
  '<='        { PT _ (TS _ 12) }
  '=='        { PT _ (TS _ 13) }
  '>'         { PT _ (TS _ 14) }
  '>='        { PT _ (TS _ 15) }
  'bool'      { PT _ (TS _ 16) }
  'false'     { PT _ (TS _ 17) }
  'int'       { PT _ (TS _ 18) }
  'k$'        { PT _ (TS _ 19) }
  'measure'   { PT _ (TS _ 20) }
  'qualifier' { PT _ (TS _ 21) }
  'true'      { PT _ (TS _ 22) }
  '||'        { PT _ (TS _ 23) }
  L_integ     { PT _ (TI $$)   }
  L_Id        { PT _ (T_Id $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Id :: { Language.Refinements.Predicates.Abs.Id }
Id  : L_Id { Language.Refinements.Predicates.Abs.Id $1 }

Pred :: { Language.Refinements.Predicates.Abs.Pred }
Pred
  : 'k$' Id '(' ListPred ')' { Language.Refinements.Predicates.Abs.HVar $2 $4 }
  | Id '(' ListPred ')' { Language.Refinements.Predicates.Abs.MeasureCall $1 $3 }
  | Integer { Language.Refinements.Predicates.Abs.ConstInt $1 }
  | ConstBool { Language.Refinements.Predicates.Abs.Boolean $1 }
  | Id { Language.Refinements.Predicates.Abs.Var $1 }
  | '(' Pred Op Pred ')' { Language.Refinements.Predicates.Abs.OpExpr $2 $3 $4 }

ConstBool :: { Language.Refinements.Predicates.Abs.ConstBool }
ConstBool
  : 'true' { Language.Refinements.Predicates.Abs.ConstTrue }
  | 'false' { Language.Refinements.Predicates.Abs.ConstFalse }

Op :: { Language.Refinements.Predicates.Abs.Op }
Op
  : '==' { Language.Refinements.Predicates.Abs.EqOp }
  | '<=' { Language.Refinements.Predicates.Abs.LessOrEqOp }
  | '<' { Language.Refinements.Predicates.Abs.LessOp }
  | '>=' { Language.Refinements.Predicates.Abs.GreaterOrEqOp }
  | '>' { Language.Refinements.Predicates.Abs.GreaterOp }
  | '+' { Language.Refinements.Predicates.Abs.PlusOp }
  | '-' { Language.Refinements.Predicates.Abs.MinusOp }
  | '*' { Language.Refinements.Predicates.Abs.MultiplyOp }
  | '&&' { Language.Refinements.Predicates.Abs.AndOp }
  | '||' { Language.Refinements.Predicates.Abs.OrOp }

ListPred :: { [Language.Refinements.Predicates.Abs.Pred] }
ListPred : Pred { (:[]) $1 } | Pred ',' ListPred { (:) $1 $3 }

Type3 :: { Language.Refinements.Predicates.Abs.Type }
Type3
  : 'bool' { Language.Refinements.Predicates.Abs.BoolType }
  | 'int' { Language.Refinements.Predicates.Abs.IntType }
  | '\'' Id { Language.Refinements.Predicates.Abs.VarType $2 }

Type2 :: { Language.Refinements.Predicates.Abs.Type }
Type2
  : Id '(' ListDataTypeArg ')' { Language.Refinements.Predicates.Abs.DataType $1 $3 }
  | '(' Type ')' { $2 }

Type1 :: { Language.Refinements.Predicates.Abs.Type }
Type1
  : Type2 '->' Type1 { Language.Refinements.Predicates.Abs.FunType $1 $3 }
  | Type2 { $1 }

DataTypeArg :: { Language.Refinements.Predicates.Abs.DataTypeArg }
DataTypeArg
  : Type { Language.Refinements.Predicates.Abs.DataTypeArg $1 }

ListDataTypeArg :: { [Language.Refinements.Predicates.Abs.DataTypeArg] }
ListDataTypeArg
  : {- empty -} { [] }
  | DataTypeArg { (:[]) $1 }
  | DataTypeArg ',' ListDataTypeArg { (:) $1 $3 }

Type :: { Language.Refinements.Predicates.Abs.Type }
Type : Type1 { $1 }

Measure :: { Language.Refinements.Predicates.Abs.Measure }
Measure
  : 'measure' Id ':' Type { Language.Refinements.Predicates.Abs.Measure $2 $4 }

ListMeasure :: { [Language.Refinements.Predicates.Abs.Measure] }
ListMeasure
  : {- empty -} { [] } | Measure ListMeasure { (:) $1 $2 }

Qualifier :: { Language.Refinements.Predicates.Abs.Qualifier }
Qualifier
  : 'qualifier' Id '(' ListQualifierArg ')' ':' Pred { Language.Refinements.Predicates.Abs.Qualifier $2 $4 $7 }

ListQualifier :: { [Language.Refinements.Predicates.Abs.Qualifier] }
ListQualifier
  : {- empty -} { [] } | Qualifier ListQualifier { (:) $1 $2 }

QualifierArg :: { Language.Refinements.Predicates.Abs.QualifierArg }
QualifierArg
  : Id ':' Type { Language.Refinements.Predicates.Abs.QualifierArg $1 $3 }

ListQualifierArg :: { [Language.Refinements.Predicates.Abs.QualifierArg] }
ListQualifierArg
  : QualifierArg { (:[]) $1 }
  | QualifierArg ',' ListQualifierArg { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

