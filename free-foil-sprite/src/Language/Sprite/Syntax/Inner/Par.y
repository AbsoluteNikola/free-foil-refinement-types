-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.Sprite.Syntax.Inner.Par
  ( happyError
  , myLexer
  , pTerm
  , pPattern
  , pScopedTerm
  , pBaseType
  , pVarBinding
  , pListVarBinding
  ) where

import Prelude

import qualified Language.Sprite.Syntax.Inner.Abs
import Language.Sprite.Syntax.Inner.Lex

}

%name pTerm Term
%name pPattern Pattern
%name pScopedTerm ScopedTerm
%name pBaseType BaseType
%name pVarBinding VarBinding
%name pListVarBinding ListVarBinding
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('        { PT _ (TS _ 1)        }
  ')'        { PT _ (TS _ 2)        }
  '*'        { PT _ (TS _ 3)        }
  '*/'       { PT _ (TS _ 4)        }
  '+'        { PT _ (TS _ 5)        }
  '-'        { PT _ (TS _ 6)        }
  '/*@'      { PT _ (TS _ 7)        }
  ':'        { PT _ (TS _ 8)        }
  ';'        { PT _ (TS _ 9)        }
  '<'        { PT _ (TS _ 10)       }
  '<='       { PT _ (TS _ 11)       }
  '='        { PT _ (TS _ 12)       }
  '=='       { PT _ (TS _ 13)       }
  '=>'       { PT _ (TS _ 14)       }
  '['        { PT _ (TS _ 15)       }
  ']'        { PT _ (TS _ 16)       }
  'false'    { PT _ (TS _ 17)       }
  'int'      { PT _ (TS _ 18)       }
  'let'      { PT _ (TS _ 19)       }
  'true'     { PT _ (TS _ 20)       }
  '{'        { PT _ (TS _ 21)       }
  '|'        { PT _ (TS _ 22)       }
  '}'        { PT _ (TS _ 23)       }
  L_integ    { PT _ (TI $$)         }
  L_VarIdent { PT _ (T_VarIdent $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

VarIdent :: { Language.Sprite.Syntax.Inner.Abs.VarIdent }
VarIdent  : L_VarIdent { Language.Sprite.Syntax.Inner.Abs.VarIdent $1 }

Term :: { Language.Sprite.Syntax.Inner.Abs.Term }
Term
  : Integer { Language.Sprite.Syntax.Inner.Abs.ConstInt $1 }
  | VarIdent { Language.Sprite.Syntax.Inner.Abs.Var $1 }
  | 'let' Term '=' Pattern ';' ScopedTerm { Language.Sprite.Syntax.Inner.Abs.Let $2 $4 $6 }
  | '(' Pattern ')' '=>' '{' ScopedTerm '}' { Language.Sprite.Syntax.Inner.Abs.Fun $2 $6 }
  | Term '(' Term ')' { Language.Sprite.Syntax.Inner.Abs.App $1 $3 }
  | '/*@' Term '*/' Term { Language.Sprite.Syntax.Inner.Abs.Ann $2 $4 }
  | BaseType '[' Pattern '|' ScopedTerm ']' { Language.Sprite.Syntax.Inner.Abs.TypeRefined $1 $3 $5 }
  | Term ':' Pattern '=>' ScopedTerm { Language.Sprite.Syntax.Inner.Abs.TypeFun $1 $3 $5 }
  | 'true' { Language.Sprite.Syntax.Inner.Abs.ConstTrue }
  | 'false' { Language.Sprite.Syntax.Inner.Abs.ConstFalse }
  | '(' Term '==' Term ')' { Language.Sprite.Syntax.Inner.Abs.PEq $2 $4 }
  | '(' Term '<=' Term ')' { Language.Sprite.Syntax.Inner.Abs.PLessOrEqThan $2 $4 }
  | '(' Term '<' Term ')' { Language.Sprite.Syntax.Inner.Abs.PLessThan $2 $4 }
  | '(' Term '<=' Term ')' { Language.Sprite.Syntax.Inner.Abs.PLessOrEqThan $2 $4 }
  | '(' Term '+' Term ')' { Language.Sprite.Syntax.Inner.Abs.Plus $2 $4 }
  | '(' Term '-' Term ')' { Language.Sprite.Syntax.Inner.Abs.Minus $2 $4 }
  | '(' Term '*' Term ')' { Language.Sprite.Syntax.Inner.Abs.Multiply $2 $4 }

Pattern :: { Language.Sprite.Syntax.Inner.Abs.Pattern }
Pattern
  : VarIdent { Language.Sprite.Syntax.Inner.Abs.PatternVar $1 }

ScopedTerm :: { Language.Sprite.Syntax.Inner.Abs.ScopedTerm }
ScopedTerm
  : Term { Language.Sprite.Syntax.Inner.Abs.ScopedTerm $1 }

BaseType :: { Language.Sprite.Syntax.Inner.Abs.BaseType }
BaseType : 'int' { Language.Sprite.Syntax.Inner.Abs.BaseTypeInt }

VarBinding :: { Language.Sprite.Syntax.Inner.Abs.VarBinding }
VarBinding
  : VarIdent ':' Term { Language.Sprite.Syntax.Inner.Abs.VarBinding $1 $3 }

ListVarBinding :: { [Language.Sprite.Syntax.Inner.Abs.VarBinding] }
ListVarBinding
  : VarBinding { (:[]) $1 }
  | VarBinding ';' ListVarBinding { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

