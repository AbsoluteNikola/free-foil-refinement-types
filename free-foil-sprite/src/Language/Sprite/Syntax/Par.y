-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.Sprite.Syntax.Par
  ( happyError
  , myLexer
  , pTerm
  ) where

import Prelude

import qualified Language.Sprite.Syntax.Abs
import Language.Sprite.Syntax.Lex

}

%name pTerm Term
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('        { PT _ (TS _ 1)        }
  ')'        { PT _ (TS _ 2)        }
  '*'        { PT _ (TS _ 3)        }
  '*/'       { PT _ (TS _ 4)        }
  '+'        { PT _ (TS _ 5)        }
  '-'        { PT _ (TS _ 6)        }
  '/*@'      { PT _ (TS _ 7)        }
  ':'        { PT _ (TS _ 8)        }
  ';'        { PT _ (TS _ 9)        }
  '<'        { PT _ (TS _ 10)       }
  '<='       { PT _ (TS _ 11)       }
  '='        { PT _ (TS _ 12)       }
  '=='       { PT _ (TS _ 13)       }
  '=>'       { PT _ (TS _ 14)       }
  '['        { PT _ (TS _ 15)       }
  ']'        { PT _ (TS _ 16)       }
  'false'    { PT _ (TS _ 17)       }
  'int'      { PT _ (TS _ 18)       }
  'let'      { PT _ (TS _ 19)       }
  'true'     { PT _ (TS _ 20)       }
  'val'      { PT _ (TS _ 21)       }
  '{'        { PT _ (TS _ 22)       }
  '|'        { PT _ (TS _ 23)       }
  '}'        { PT _ (TS _ 24)       }
  L_integ    { PT _ (TI $$)         }
  L_VarIdent { PT _ (T_VarIdent $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

VarIdent :: { Language.Sprite.Syntax.Abs.VarIdent }
VarIdent  : L_VarIdent { Language.Sprite.Syntax.Abs.VarIdent $1 }

Term :: { Language.Sprite.Syntax.Abs.Term }
Term
  : Integer { Language.Sprite.Syntax.Abs.ConstInt $1 }
  | VarIdent { Language.Sprite.Syntax.Abs.Var $1 }
  | Decl ScopedTerm { Language.Sprite.Syntax.Abs.Let $1 $2 }
  | '(' VarIdent ')' '=>' '{' ScopedTerm '}' { Language.Sprite.Syntax.Abs.Fun $2 $6 }
  | Term '(' Term ')' { Language.Sprite.Syntax.Abs.App $1 $3 }
  | Term IntOp Term { Language.Sprite.Syntax.Abs.Op $1 $2 $3 }
  | '(' Term ')' { $2 }

Annotation :: { Language.Sprite.Syntax.Abs.Annotation }
Annotation
  : '/*@' 'val' VarIdent ':' RType '*/' { Language.Sprite.Syntax.Abs.Annotation $3 $5 }

PlainDecl :: { Language.Sprite.Syntax.Abs.PlainDecl }
PlainDecl
  : 'let' VarIdent '=' Term ';' { Language.Sprite.Syntax.Abs.PlainDecl $2 $4 }

Decl :: { Language.Sprite.Syntax.Abs.Decl }
Decl
  : Annotation PlainDecl { Language.Sprite.Syntax.Abs.AnnotatedDecl $1 $2 }
  | PlainDecl { Language.Sprite.Syntax.Abs.UnAnnotatedDecl $1 }

ListDecl :: { [Language.Sprite.Syntax.Abs.Decl] }
ListDecl : {- empty -} { [] } | Decl ListDecl { (:) $1 $2 }

IntOp :: { Language.Sprite.Syntax.Abs.IntOp }
IntOp
  : '+' { Language.Sprite.Syntax.Abs.IntPlus }
  | '-' { Language.Sprite.Syntax.Abs.IntMinus }
  | '*' { Language.Sprite.Syntax.Abs.IntMultiply }

RType :: { Language.Sprite.Syntax.Abs.RType }
RType
  : BaseType '[' VarIdent '|' Pred ']' { Language.Sprite.Syntax.Abs.TypeRefined $1 $3 $5 }
  | BaseType { Language.Sprite.Syntax.Abs.TypeRefinedBase $1 }
  | FuncArg '=>' ScopedRType { Language.Sprite.Syntax.Abs.TypeFun $1 $3 }
  | '(' RType ')' { $2 }

ScopedRType :: { Language.Sprite.Syntax.Abs.ScopedRType }
ScopedRType : RType { Language.Sprite.Syntax.Abs.ScopedRType $1 }

FuncArg :: { Language.Sprite.Syntax.Abs.FuncArg }
FuncArg
  : RType { Language.Sprite.Syntax.Abs.UnNamedFuncArg $1 }
  | VarIdent ':' RType { Language.Sprite.Syntax.Abs.NamedFuncArg $1 $3 }

Pred :: { Language.Sprite.Syntax.Abs.Pred }
Pred
  : VarIdent { Language.Sprite.Syntax.Abs.PVar $1 }
  | 'true' { Language.Sprite.Syntax.Abs.PTrue }
  | 'false' { Language.Sprite.Syntax.Abs.PFalse }
  | Integer { Language.Sprite.Syntax.Abs.PInt $1 }
  | Pred '==' Pred { Language.Sprite.Syntax.Abs.PEq $1 $3 }
  | Pred '<' Pred { Language.Sprite.Syntax.Abs.PLessThan $1 $3 }
  | Pred '<=' Pred { Language.Sprite.Syntax.Abs.PLessOrEqThan $1 $3 }
  | Pred '+' Pred { Language.Sprite.Syntax.Abs.PPlus $1 $3 }
  | Pred '-' Pred { Language.Sprite.Syntax.Abs.PMinus $1 $3 }
  | Pred '*' Pred { Language.Sprite.Syntax.Abs.PMultiply $1 $3 }

Pattern :: { Language.Sprite.Syntax.Abs.Pattern }
Pattern : VarIdent { Language.Sprite.Syntax.Abs.PatternVar $1 }

ScopedTerm :: { Language.Sprite.Syntax.Abs.ScopedTerm }
ScopedTerm : Term { Language.Sprite.Syntax.Abs.ScopedTerm $1 }

BaseType :: { Language.Sprite.Syntax.Abs.BaseType }
BaseType : 'int' { Language.Sprite.Syntax.Abs.BaseTypeInt }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

