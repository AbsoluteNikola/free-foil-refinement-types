-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Language.Sprite.Syntax.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Language.Sprite.Syntax.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transVarIdent :: Language.Sprite.Syntax.Abs.VarIdent -> Result
transVarIdent x = case x of
  Language.Sprite.Syntax.Abs.VarIdent string -> failure x

transTerm :: Language.Sprite.Syntax.Abs.Term -> Result
transTerm x = case x of
  Language.Sprite.Syntax.Abs.ConstInt integer -> failure x
  Language.Sprite.Syntax.Abs.Var varident -> failure x
  Language.Sprite.Syntax.Abs.Let decl scopedterm -> failure x
  Language.Sprite.Syntax.Abs.Fun varident scopedterm -> failure x
  Language.Sprite.Syntax.Abs.App term1 term2 -> failure x
  Language.Sprite.Syntax.Abs.Op term1 intop term2 -> failure x

transAnnotation :: Language.Sprite.Syntax.Abs.Annotation -> Result
transAnnotation x = case x of
  Language.Sprite.Syntax.Abs.Annotation varident rtype -> failure x

transPlainDecl :: Language.Sprite.Syntax.Abs.PlainDecl -> Result
transPlainDecl x = case x of
  Language.Sprite.Syntax.Abs.PlainDecl varident term -> failure x

transDecl :: Language.Sprite.Syntax.Abs.Decl -> Result
transDecl x = case x of
  Language.Sprite.Syntax.Abs.AnnotatedDecl annotation plaindecl -> failure x
  Language.Sprite.Syntax.Abs.UnAnnotatedDecl plaindecl -> failure x

transIntOp :: Language.Sprite.Syntax.Abs.IntOp -> Result
transIntOp x = case x of
  Language.Sprite.Syntax.Abs.IntPlus -> failure x
  Language.Sprite.Syntax.Abs.IntMinus -> failure x
  Language.Sprite.Syntax.Abs.IntMultiply -> failure x

transRType :: Language.Sprite.Syntax.Abs.RType -> Result
transRType x = case x of
  Language.Sprite.Syntax.Abs.TypeRefined basetype varident pred -> failure x
  Language.Sprite.Syntax.Abs.TypeRefinedBase basetype -> failure x
  Language.Sprite.Syntax.Abs.TypeFun funcarg scopedrtype -> failure x

transScopedRType :: Language.Sprite.Syntax.Abs.ScopedRType -> Result
transScopedRType x = case x of
  Language.Sprite.Syntax.Abs.ScopedRType rtype -> failure x

transFuncArg :: Language.Sprite.Syntax.Abs.FuncArg -> Result
transFuncArg x = case x of
  Language.Sprite.Syntax.Abs.UnNamedFuncArg rtype -> failure x
  Language.Sprite.Syntax.Abs.NamedFuncArg varident rtype -> failure x

transPred :: Language.Sprite.Syntax.Abs.Pred -> Result
transPred x = case x of
  Language.Sprite.Syntax.Abs.PVar varident -> failure x
  Language.Sprite.Syntax.Abs.PTrue -> failure x
  Language.Sprite.Syntax.Abs.PFalse -> failure x
  Language.Sprite.Syntax.Abs.PInt integer -> failure x
  Language.Sprite.Syntax.Abs.PEq pred1 pred2 -> failure x
  Language.Sprite.Syntax.Abs.PLessThan pred1 pred2 -> failure x
  Language.Sprite.Syntax.Abs.PLessOrEqThan pred1 pred2 -> failure x
  Language.Sprite.Syntax.Abs.PPlus pred1 pred2 -> failure x
  Language.Sprite.Syntax.Abs.PMinus pred1 pred2 -> failure x
  Language.Sprite.Syntax.Abs.PMultiply pred1 pred2 -> failure x

transPattern :: Language.Sprite.Syntax.Abs.Pattern -> Result
transPattern x = case x of
  Language.Sprite.Syntax.Abs.PatternVar varident -> failure x

transScopedTerm :: Language.Sprite.Syntax.Abs.ScopedTerm -> Result
transScopedTerm x = case x of
  Language.Sprite.Syntax.Abs.ScopedTerm term -> failure x

transBaseType :: Language.Sprite.Syntax.Abs.BaseType -> Result
transBaseType x = case x of
  Language.Sprite.Syntax.Abs.BaseTypeInt -> failure x
