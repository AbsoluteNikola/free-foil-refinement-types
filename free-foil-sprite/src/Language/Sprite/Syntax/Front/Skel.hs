-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Language.Sprite.Syntax.Front.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Language.Sprite.Syntax.Front.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transVarIdent :: Language.Sprite.Syntax.Front.Abs.VarIdent -> Result
transVarIdent x = case x of
  Language.Sprite.Syntax.Front.Abs.VarIdent string -> failure x

transProgram :: Language.Sprite.Syntax.Front.Abs.Program -> Result
transProgram x = case x of
  Language.Sprite.Syntax.Front.Abs.Program qualifiers term -> failure x

transQualifier :: Language.Sprite.Syntax.Front.Abs.Qualifier -> Result
transQualifier x = case x of
  Language.Sprite.Syntax.Front.Abs.Qualifier varident qualifierargs pred -> failure x

transQualifierArg :: Language.Sprite.Syntax.Front.Abs.QualifierArg -> Result
transQualifierArg x = case x of
  Language.Sprite.Syntax.Front.Abs.QualifierArg varident basetype -> failure x

transTerm :: Language.Sprite.Syntax.Front.Abs.Term -> Result
transTerm x = case x of
  Language.Sprite.Syntax.Front.Abs.ConstInt integer -> failure x
  Language.Sprite.Syntax.Front.Abs.Bool constbool -> failure x
  Language.Sprite.Syntax.Front.Abs.Var varident -> failure x
  Language.Sprite.Syntax.Front.Abs.If funcapparg term1 term2 -> failure x
  Language.Sprite.Syntax.Front.Abs.Let decl term -> failure x
  Language.Sprite.Syntax.Front.Abs.Fun varident term -> failure x
  Language.Sprite.Syntax.Front.Abs.App varident funcapparg -> failure x
  Language.Sprite.Syntax.Front.Abs.Op funcapparg1 intop funcapparg2 -> failure x

transConstBool :: Language.Sprite.Syntax.Front.Abs.ConstBool -> Result
transConstBool x = case x of
  Language.Sprite.Syntax.Front.Abs.ConstTrue -> failure x
  Language.Sprite.Syntax.Front.Abs.ConstFalse -> failure x

transAnnotation :: Language.Sprite.Syntax.Front.Abs.Annotation -> Result
transAnnotation x = case x of
  Language.Sprite.Syntax.Front.Abs.Annotation varident rtype -> failure x

transDecl :: Language.Sprite.Syntax.Front.Abs.Decl -> Result
transDecl x = case x of
  Language.Sprite.Syntax.Front.Abs.RecDecl annotation varident term -> failure x
  Language.Sprite.Syntax.Front.Abs.AnnotatedDecl annotation varident term -> failure x
  Language.Sprite.Syntax.Front.Abs.UnAnnotatedDecl varident term -> failure x

transIntOp :: Language.Sprite.Syntax.Front.Abs.IntOp -> Result
transIntOp x = case x of
  Language.Sprite.Syntax.Front.Abs.IntPlus -> failure x
  Language.Sprite.Syntax.Front.Abs.IntMinus -> failure x
  Language.Sprite.Syntax.Front.Abs.IntMultiply -> failure x
  Language.Sprite.Syntax.Front.Abs.IntEq -> failure x
  Language.Sprite.Syntax.Front.Abs.IntLessThan -> failure x
  Language.Sprite.Syntax.Front.Abs.IntLessOrEqThan -> failure x
  Language.Sprite.Syntax.Front.Abs.IntGreaterThan -> failure x
  Language.Sprite.Syntax.Front.Abs.IntGreaterOrEqThan -> failure x

transRType :: Language.Sprite.Syntax.Front.Abs.RType -> Result
transRType x = case x of
  Language.Sprite.Syntax.Front.Abs.TypeRefined basetype varident pred -> failure x
  Language.Sprite.Syntax.Front.Abs.TypeRefinedUnknown basetype -> failure x
  Language.Sprite.Syntax.Front.Abs.TypeRefinedSimple basetype -> failure x
  Language.Sprite.Syntax.Front.Abs.TypeVar varident -> failure x
  Language.Sprite.Syntax.Front.Abs.TypeFun funcarg rtype -> failure x

transFuncArg :: Language.Sprite.Syntax.Front.Abs.FuncArg -> Result
transFuncArg x = case x of
  Language.Sprite.Syntax.Front.Abs.NamedFuncArg varident rtype -> failure x
  Language.Sprite.Syntax.Front.Abs.UnNamedFuncArg rtype -> failure x

transPred :: Language.Sprite.Syntax.Front.Abs.Pred -> Result
transPred x = case x of
  Language.Sprite.Syntax.Front.Abs.PVar varident -> failure x
  Language.Sprite.Syntax.Front.Abs.PBool constbool -> failure x
  Language.Sprite.Syntax.Front.Abs.PInt integer -> failure x
  Language.Sprite.Syntax.Front.Abs.POr pred1 pred2 -> failure x
  Language.Sprite.Syntax.Front.Abs.PAnd pred1 pred2 -> failure x
  Language.Sprite.Syntax.Front.Abs.PEq pred1 pred2 -> failure x
  Language.Sprite.Syntax.Front.Abs.PLessThan pred1 pred2 -> failure x
  Language.Sprite.Syntax.Front.Abs.PLessOrEqThan pred1 pred2 -> failure x
  Language.Sprite.Syntax.Front.Abs.PGreaterThan pred1 pred2 -> failure x
  Language.Sprite.Syntax.Front.Abs.PGreaterOrEqThan pred1 pred2 -> failure x
  Language.Sprite.Syntax.Front.Abs.PPlus pred1 pred2 -> failure x
  Language.Sprite.Syntax.Front.Abs.PMinus pred1 pred2 -> failure x
  Language.Sprite.Syntax.Front.Abs.PMultiply pred1 pred2 -> failure x

transBaseType :: Language.Sprite.Syntax.Front.Abs.BaseType -> Result
transBaseType x = case x of
  Language.Sprite.Syntax.Front.Abs.BaseTypeInt -> failure x
  Language.Sprite.Syntax.Front.Abs.BaseTypeBool -> failure x

transFuncAppArg :: Language.Sprite.Syntax.Front.Abs.FuncAppArg -> Result
transFuncAppArg x = case x of
  Language.Sprite.Syntax.Front.Abs.FuncAppArgBool constbool -> failure x
  Language.Sprite.Syntax.Front.Abs.FuncAppArgInt integer -> failure x
  Language.Sprite.Syntax.Front.Abs.FuncAppArgVar varident -> failure x
